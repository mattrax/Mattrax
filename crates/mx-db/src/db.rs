// This file was generated by '@mattrax/drizzle-to-rs'
#![allow(unused)]
use chrono::NaiveDateTime;
use mysql_async::{prelude::*, BinaryProtocol, Deserialized, QueryResult, Serialized};

// 'FromValue::from_value' but 'track_caller'
#[track_caller]
fn from_value<T: FromValue>(row: &mut mysql_async::Row, index: usize) -> T {
    let v = row.take(index).unwrap();
    match T::from_value_opt(v) {
        Ok(this) => this,
        Err(e) => {
            let column_name = row
                .columns_ref()
                .get(index)
                .map(|c| c.name_str())
                .unwrap_or("unknown".into());
            let type_name = std::any::type_name::<T>();
            panic!("Could not retrieve {type_name:?} from column {column_name:?}: {e}")
        }
    }
}

#[derive(Clone)]
pub struct Db {
    pool: mysql_async::Pool,
}

impl std::ops::Deref for Db {
    type Target = mysql_async::Pool;

    fn deref(&self) -> &Self::Target {
        &self.pool
    }
}

impl std::ops::DerefMut for Db {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.pool
    }
}

impl Db {
    pub fn new(db_url: &str) -> Self {
        Self {
            pool: mysql_async::Pool::new(db_url),
        }
    }
}
