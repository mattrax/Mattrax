// This file was generated by '@mattrax/drizzle-to-rs'
#![allow(unused)]
use chrono::NaiveDateTime;
use mysql_async::{prelude::*, BinaryProtocol, Deserialized, QueryResult, Serialized};

#[derive(Debug)]
pub struct GetConfigResult {
    pub value: Vec<u8>,
}

#[derive(Debug)]
pub struct GetNodeResult {
    pub value: Vec<u8>,
}

#[derive(Debug)]
pub struct GetCertificateResult {
    pub value: Vec<u8>,
}

#[derive(Debug)]
pub struct GetDeviceResult {
    pub pk: u64,
    pub tenant_pk: u64,
}
#[derive(Debug)]
pub struct GetPolicyDataForCheckinLatestDeployResult {
    pub pk: u64,
    pub data: Deserialized<serde_json::Value>,
}
#[derive(Debug)]
pub struct GetPolicyDataForCheckinLastDeployResult {
    pub pk: u64,
    pub data: Deserialized<serde_json::Value>,
    pub result: Deserialized<serde_json::Value>,
}
#[derive(Debug)]
pub struct GetPolicyDataForCheckinResult {
    pub scope: String,
    pub latest_deploy: GetPolicyDataForCheckinLatestDeployResult,
    pub last_deploy: Option<GetPolicyDataForCheckinLastDeployResult>,
}
#[derive(Debug)]
pub struct QueuedDeviceActionsResult {
    pub action: String,
    pub device_pk: u64,
    pub created_by: u64,
    pub created_at: NaiveDateTime,
    pub deployed_at: Option<NaiveDateTime>,
}

#[derive(Clone)]
pub struct Db {
    pool: mysql_async::Pool,
}

impl std::ops::Deref for Db {
    type Target = mysql_async::Pool;

    fn deref(&self) -> &Self::Target {
        &self.pool
    }
}

impl std::ops::DerefMut for Db {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.pool
    }
}

impl Db {
    pub fn new(db_url: &str) -> Self {
        Self {
            pool: mysql_async::Pool::new(db_url),
        }
    }
}

impl Db {
    pub async fn get_config(&self) -> Result<Vec<GetConfigResult>, mysql_async::Error> {
        let mut result = r#"select `value` from `kv` where `kv`.`key` = ?"#
            .with(mysql_async::Params::Positional(vec!["config"
                .clone()
                .into()]))
            .run(&self.pool)
            .await?;
        let mut ret = vec![];
        while let Some(mut row) = result.next().await.unwrap() {
            ret.push(GetConfigResult {
                value: FromValue::from_value(row.take(0).unwrap()),
            });
        }
        Ok(ret)
    }
}
impl Db {
    pub async fn set_config(&self, config: String) -> Result<(), mysql_async::Error> {
        let mut result = r#"insert into `kv` (`key`, `value`, `last_modified`) values (?, ?, default) on duplicate key update `value` = ?"#
			  .with(mysql_async::Params::Positional(vec!["config".clone().into(),config.clone().into(),config.clone().into()]))
					.run(&self.pool).await?;
        Ok(())
    }
}
impl Db {
    pub async fn get_node(&self, id: String) -> Result<Vec<GetNodeResult>, mysql_async::Error> {
        let mut result = r#"select `value` from `kv` where `kv`.`key` = CONCAT('server:', ?)"#
            .with(mysql_async::Params::Positional(vec![id.clone().into()]))
            .run(&self.pool)
            .await?;
        let mut ret = vec![];
        while let Some(mut row) = result.next().await.unwrap() {
            ret.push(GetNodeResult {
                value: FromValue::from_value(row.take(0).unwrap()),
            });
        }
        Ok(ret)
    }
}
impl Db {
    pub async fn update_node(&self, id: String, config: String) -> Result<(), mysql_async::Error> {
        let mut result = r#"insert into `kv` (`key`, `value`, `last_modified`) values (CONCAT('server:', ?), ?, default) on duplicate key update `value` = ?"#
			  .with(mysql_async::Params::Positional(vec![id.clone().into(),config.clone().into(),config.clone().into()]))
					.run(&self.pool).await?;
        Ok(())
    }
}
impl Db {
    pub async fn get_certificate(
        &self,
        key: String,
    ) -> Result<Vec<GetCertificateResult>, mysql_async::Error> {
        let mut result = r#"select `value` from `kv` where `kv`.`key` = CONCAT('cert:', ?)"#
            .with(mysql_async::Params::Positional(vec![key.clone().into()]))
            .run(&self.pool)
            .await?;
        let mut ret = vec![];
        while let Some(mut row) = result.next().await.unwrap() {
            ret.push(GetCertificateResult {
                value: FromValue::from_value(row.take(0).unwrap()),
            });
        }
        Ok(ret)
    }
}
impl Db {
    pub async fn store_certificate(
        &self,
        key: String,
        certificate: Vec<u8>,
    ) -> Result<(), mysql_async::Error> {
        let last_modified = chrono::Utc::now().naive_utc();
        let mut result = r#"insert into `kv` (`key`, `value`, `last_modified`) values (CONCAT('cert:', ?), ?, default) on duplicate key update `value` = ?, `last_modified` = NOW()"#
			  .with(mysql_async::Params::Positional(vec![key.clone().into(),certificate.clone().into(),certificate.clone().into()]))
					.run(&self.pool).await?;
        Ok(())
    }
}
impl Db {
    pub async fn create_device(
        &self,
        id: String,
        name: String,
        enrollment_type: String,
        os: String,
        serial_number: String,
        tenant_pk: u64,
        owner_pk: u64,
    ) -> Result<(), mysql_async::Error> {
        let mut result = r#"insert into `devices` (`pk`, `id`, `name`, `description`, `enrollment_type`, `os`, `serial_number`, `manufacturer`, `model`, `os_version`, `imei`, `free_storage`, `total_storage`, `owner`, `azure_ad_did`, `enrolled_at`, `last_synced`, `tenant`) values (default, ?, ?, default, ?, ?, ?, default, default, default, default, default, default, ?, default, default, default, ?) on duplicate key update `name` = ?, `owner` = ?, `tenant` = ?"#
			  .with(mysql_async::Params::Positional(vec![id.clone().into(),name.clone().into(),enrollment_type.clone().into(),os.clone().into(),serial_number.clone().into(),owner_pk.clone().into(),tenant_pk.clone().into(),name.clone().into(),owner_pk.clone().into(),tenant_pk.clone().into()]))
					.run(&self.pool).await?;
        Ok(())
    }
}
impl Db {
    pub async fn get_device(
        &self,
        device_id: String,
    ) -> Result<Vec<GetDeviceResult>, mysql_async::Error> {
        let mut result = r#"select `pk`, `tenant` from `devices` where `devices`.`id` = ?"#
            .with(mysql_async::Params::Positional(vec![device_id
                .clone()
                .into()]))
            .run(&self.pool)
            .await?;
        let mut ret = vec![];
        while let Some(mut row) = result.next().await.unwrap() {
            ret.push(GetDeviceResult {
                pk: FromValue::from_value(row.take(0).unwrap()),
                tenant_pk: FromValue::from_value(row.take(1).unwrap()),
            });
        }
        Ok(ret)
    }
}
impl Db {
    pub async fn get_policy_data_for_checkin(
        &self,
        device_pk: u64,
    ) -> Result<Vec<GetPolicyDataForCheckinResult>, mysql_async::Error> {
        let mut result = r#"select `scope_li`, `l`.`pk`, `l`.`data`, `j`.`pk`, `j`.`data`, `j`.`result` from (select `policy_deploy`.`pk`, `policy_deploy`.`policy`, `policy_deploy`.`data`, `scope_li` from `policy_deploy` inner join (select max(`policy_deploy`.`pk`) as `deployPk`, `policy_deploy`.`policy`, max(`scope`) as `scope_li` from (select `pk`, min(`scope`) as `scope` from ((select `policies`.`pk`, 'direct' as `scope` from `policies` inner join `policy_assignables` on `policies`.`pk` = `policy_assignables`.`policy` where (`policy_assignables`.`variant` = ? and `policy_assignables`.`pk` = ?)) union all (select `policies`.`pk`, 'group' as `scope` from `policies` inner join `policy_assignables` on (`policies`.`pk` = `policy_assignables`.`policy` and `policy_assignables`.`variant` = ?) inner join `group_assignables` on `group_assignables`.`group` = `policy_assignables`.`pk` where (`group_assignables`.`variant` = ? and `group_assignables`.`pk` = ?))) `scoped` group by `scoped`.`pk`) `sorted` inner join `policy_deploy` on `sorted`.`pk` = `policy_deploy`.`policy` group by `policy_deploy`.`policy`) `li` on `deployPk` = `policy_deploy`.`pk`) `l` left join (select `policy_deploy`.`pk`, `policy_deploy`.`policy`, `policy_deploy`.`data`, `policy_deploy_status`.`result`, `ji_scope` from `policy_deploy` inner join (select max(`policy_deploy`.`pk`) as `deployPk`, `policy_deploy`.`policy`, max(`scope`) as `ji_scope` from (select `pk`, min(`scope`) as `scope` from ((select `policies`.`pk`, 'direct' as `scope` from `policies` inner join `policy_assignables` on `policies`.`pk` = `policy_assignables`.`policy` where (`policy_assignables`.`variant` = ? and `policy_assignables`.`pk` = ?)) union all (select `policies`.`pk`, 'group' as `scope` from `policies` inner join `policy_assignables` on (`policies`.`pk` = `policy_assignables`.`policy` and `policy_assignables`.`variant` = ?) inner join `group_assignables` on `group_assignables`.`group` = `policy_assignables`.`pk` where (`group_assignables`.`variant` = ? and `group_assignables`.`pk` = ?))) `scoped` group by `scoped`.`pk`) `sorted` inner join `policy_deploy` on `sorted`.`pk` = `policy_deploy`.`policy` inner join `policy_deploy_status` on (`policy_deploy`.`pk` = `policy_deploy_status`.`deploy` and `policy_deploy_status`.`device` = ?) group by `policy_deploy`.`policy`) `ji` on `deployPk` = `policy_deploy`.`pk` inner join `policy_deploy_status` on (`policy_deploy`.`pk` = `policy_deploy_status`.`deploy` and `policy_deploy_status`.`device` = ?)) `j` on `j`.`policy` = `l`.`policy`"#
			  .with(mysql_async::Params::Positional(vec!["device".clone().into(),device_pk.clone().into(),"group".clone().into(),"device".clone().into(),device_pk.clone().into(),"device".clone().into(),device_pk.clone().into(),"group".clone().into(),"device".clone().into(),device_pk.clone().into(),device_pk.clone().into(),device_pk.clone().into()]))
					.run(&self.pool).await?;
        let mut ret = vec![];
        while let Some(mut row) = result.next().await.unwrap() {
            ret.push(GetPolicyDataForCheckinResult {
                scope: FromValue::from_value(row.take(0).unwrap()),
                latest_deploy: GetPolicyDataForCheckinLatestDeployResult {
                    pk: FromValue::from_value(row.take(1).unwrap()),
                    data: FromValue::from_value(row.take(2).unwrap()),
                },
                last_deploy: {
                    let pk = row.take(3).map(FromValue::from_value);
                    let data = row.take(4).map(FromValue::from_value);
                    let result = row.take(5).map(FromValue::from_value);

                    match (pk, data, result) {
                        (Some(pk), Some(data), Some(result)) => {
                            Some(GetPolicyDataForCheckinLastDeployResult { pk, data, result })
                        }
                        _ => None,
                    }
                },
            });
        }
        Ok(ret)
    }
}
impl Db {
    pub async fn queued_device_actions(
        &self,
        device_id: u64,
    ) -> Result<Vec<QueuedDeviceActionsResult>, mysql_async::Error> {
        let mut result = r#"select `action`, `device`, `created_by`, `created_at`, `deployed_at` from `device_actions` where (`device_actions`.`device` = ? and `device_actions`.`deployed_at` is null)"#
			  .with(mysql_async::Params::Positional(vec![device_id.clone().into()]))
					.run(&self.pool).await?;
        let mut ret = vec![];
        while let Some(mut row) = result.next().await.unwrap() {
            ret.push(QueuedDeviceActionsResult {
                action: FromValue::from_value(row.take(0).unwrap()),
                device_pk: FromValue::from_value(row.take(1).unwrap()),
                created_by: FromValue::from_value(row.take(2).unwrap()),
                created_at: FromValue::from_value(row.take(3).unwrap()),
                deployed_at: FromValue::from_value(row.take(4).unwrap()),
            });
        }
        Ok(ret)
    }
}
impl Db {
    pub async fn update_device_lastseen(&self, device_id: u64) -> Result<(), mysql_async::Error> {
        let last_synced = chrono::Utc::now().naive_utc();
        let mut result = r#"update `devices` set `last_synced` = ? where `devices`.`pk` = ?"#
            .with(mysql_async::Params::Positional(vec![
                last_synced.clone().into(),
                device_id.clone().into(),
            ]))
            .run(&self.pool)
            .await?;
        Ok(())
    }
}
