// This file was generated by '@mattrax/drizzle-to-rs'
#![allow(unused)]
use chrono::NaiveDateTime;
use mysql_async::{prelude::*, Deserialized, Serialized};

#[derive(Debug)]
pub struct GetCertificateResult {
    pub certificate: Vec<u8>,
}

#[derive(Debug)]
pub struct GetDeviceResult {
    pub pk: i64,
    pub tenant_pk: i64,
}
#[derive(Debug)]
pub struct GetDeviceDirectlyScopedPoliciesResult {
    pub pk: i64,
    pub id: String,
    pub name: String,
}
#[derive(Debug)]
pub struct GetDeviceGroupsResult {
    pub pk: i64,
    pub id: String,
    pub name: String,
}
#[derive(Debug)]
pub struct GetGroupPolicyDeploysResult {
    pub pk: i64,
    pub data: serde_json::Value,
    pub priority: i64,
}
#[derive(Debug)]
pub struct QueuedDeviceActionsResult {
    pub action: String,
    pub device_pk: i64,
    pub created_by: i64,
    pub created_at: NaiveDateTime,
    pub deployed_at: Option<NaiveDateTime>,
}

pub struct DbInner {
    client: tokio_postgres::Client,
}

#[derive(Clone)]
pub struct Db(std::sync::Arc<DbInner>);

impl std::ops::Deref for Db {
    type Target = DbInner;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl Db {
    pub async fn new(db_url: &str) -> Self {
        let (client, connection) = tokio_postgres::connect(
            db_url,
            postgres_native_tls::MakeTlsConnector::new(
                native_tls::TlsConnector::builder().build().unwrap(),
            ),
        )
        .await
        .unwrap();

        tokio::spawn(async move {
            if let Err(e) = connection.await {
                eprintln!("connection error: {}", e);
            }
        });

        Self(std::sync::Arc::new(DbInner { client }))
    }
}

impl Db {
    pub async fn get_certificate(
        &self,
        key: String,
    ) -> Result<Vec<GetCertificateResult>, tokio_postgres::Error> {
        let resp = self
            .0
            .client
            .query(
                r#"select "certificate" from "certificates" where "certificates"."key" = $1"#,
                &[&key],
            )
            .await?;
        Ok(resp
            .into_iter()
            .map(|row| GetCertificateResult {
                certificate: row.get("certificate"),
            })
            .collect())
    }
}
impl Db {
    pub async fn store_certificate(
        &self,
        key: String,
        certificate: Vec<u8>,
    ) -> Result<(), tokio_postgres::Error> {
        let last_modified = chrono::Utc::now().naive_utc();
        let resp = self.0.client.query(r#"insert into "certificates" ("key", "certificate", "last_modified") values ($1, $2, $3) on conflict ("key") do update set "certificate" = $4, "last_modified" = $5"#, &[&key,&certificate,&last_modified,&certificate,&last_modified]).await?;
        Ok(())
    }
}
impl Db {
    pub async fn create_device(
        &self,
        id: String,
        name: String,
        enrollment_type: String,
        os: String,
        serial_number: String,
        tenant_pk: i64,
        owner_pk: i64,
    ) -> Result<(), tokio_postgres::Error> {
        let resp = self.0.client.query(r#"insert into "devices" ("pk", "id", "name", "description", "enrollment_type", "os", "serial_number", "manufacturer", "model", "os_version", "imei", "free_storage", "total_storage", "owner", "azure_ad_did", "enrolled_at", "last_synced", "tenant") values (default, $1, $2, default, $3, $4, $5, default, default, default, default, default, default, $6, default, default, default, $7) on conflict ("id") do update set "name" = $8, "tenant" = $9, "owner" = $10"#, &[&id,&name,&enrollment_type,&os,&serial_number,&owner_pk,&tenant_pk,&name,&tenant_pk,&owner_pk]).await?;
        Ok(())
    }
}
impl Db {
    pub async fn get_device(
        &self,
        device_id: String,
    ) -> Result<Vec<GetDeviceResult>, tokio_postgres::Error> {
        let resp = self
            .0
            .client
            .query(
                r#"select "pk", "tenant" from "devices" where "devices"."id" = $1"#,
                &[&device_id],
            )
            .await?;
        Ok(resp
            .into_iter()
            .map(|row| GetDeviceResult {
                pk: row.get("pk"),
                tenant_pk: row.get("tenantPk"),
            })
            .collect())
    }
}
impl Db {
    pub async fn get_device_directly_scoped_policies(
        &self,
        device_pk: i64,
    ) -> Result<Vec<GetDeviceDirectlyScopedPoliciesResult>, tokio_postgres::Error> {
        let resp = self.0.client.query(r#"select "policies"."pk", "policies"."id", "policies"."name" from "policies" inner join "policy_assignables" on "policies"."pk" = "policy_assignables"."policy" where ("policy_assignables"."variant" = $1 and "policy_assignables"."pk" = $2)"#, &[&"device",&device_pk]).await?;
        Ok(resp
            .into_iter()
            .map(|row| GetDeviceDirectlyScopedPoliciesResult {
                pk: row.get("pk"),
                id: row.get("id"),
                name: row.get("name"),
            })
            .collect())
    }
}
impl Db {
    pub async fn get_device_groups(
        &self,
        device_pk: i64,
    ) -> Result<Vec<GetDeviceGroupsResult>, tokio_postgres::Error> {
        let resp = self.0.client.query(r#"select "policies"."pk", "policies"."id", "policies"."name" from "policies" inner join "policy_assignables" on "policies"."pk" = "policy_assignables"."policy" inner join "group_assignables" on ("group_assignables"."group" = "policy_assignables"."pk" and "policy_assignables"."variant" = $1) where ("group_assignables"."variant" = $2 and "group_assignables"."pk" = $3)"#, &[&"group",&"device",&device_pk]).await?;
        Ok(resp
            .into_iter()
            .map(|row| GetDeviceGroupsResult {
                pk: row.get("pk"),
                id: row.get("id"),
                name: row.get("name"),
            })
            .collect())
    }
}
impl Db {
    pub async fn get_group_policy_deploys(
        &self,
        group_pk: i64,
    ) -> Result<Vec<GetGroupPolicyDeploysResult>, tokio_postgres::Error> {
        let resp = self.0.client.query(r#"select "policy_deploy"."pk", "policy_deploy"."data", "policies"."priority" from "policy_deploy" inner join "policy_assignables" on "policy_deploy"."policy" = "policy_assignables"."policy" inner join "policies" on "policies"."pk" = "policy_assignables"."policy" where ("policy_assignables"."variant" = $1 and "policy_assignables"."pk" = $2 and "policy_deploy"."done_at" = (SELECT MAX("policy_deploy"."done_at") FROM "policy_deploy" WHERE "policy_deploy"."policy" = "policy_assignables"."policy"))"#, &[&"group",&group_pk]).await?;
        Ok(resp
            .into_iter()
            .map(|row| GetGroupPolicyDeploysResult {
                pk: row.get("pk"),
                data: row.get("data"),
                priority: row.get("priority"),
            })
            .collect())
    }
}
impl Db {
    pub async fn queued_device_actions(
        &self,
        device_id: i64,
    ) -> Result<Vec<QueuedDeviceActionsResult>, tokio_postgres::Error> {
        let resp = self.0.client.query(r#"select "action", "device", "created_by", "created_at", "deployed_at" from "device_actions" where ("device_actions"."device" = $1 and "device_actions"."deployed_at" is null)"#, &[&device_id]).await?;
        Ok(resp
            .into_iter()
            .map(|row| QueuedDeviceActionsResult {
                action: row.get("action"),
                device_pk: row.get("devicePk"),
                created_by: row.get("createdBy"),
                created_at: row.get("createdAt"),
                deployed_at: row.get("deployedAt"),
            })
            .collect())
    }
}
impl Db {
    pub async fn update_device_lastseen(
        &self,
        device_id: i64,
    ) -> Result<(), tokio_postgres::Error> {
        let last_synced = chrono::Utc::now().naive_utc();
        let resp = self
            .0
            .client
            .query(
                r#"update "devices" set "last_synced" = $1 where "devices"."pk" = $2"#,
                &[&last_synced, &device_id],
            )
            .await?;
        Ok(())
    }
}
